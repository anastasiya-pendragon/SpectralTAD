#Get distance between points on circle
point_dist = sqrt(rowSums( (eig_vecs-rbind(NA,eig_vecs[-nrow(eig_vecs),]))^2  ))
#Use z-score to select significant gaps
if (z_clust) {
#Get statisticaly significant boundaries
sig_bounds = which(scale(point_dist[-length(point_dist)])>2)
#Remove boundaries within the minimum size
sig_bounds = subset(sig_bounds, sig_bounds>min_size)
#2*min_size is to offset and remove the second occurence
dist_bounds = which(c(min_size*2,diff(sig_bounds))<min_size)
#Remove bounds within the mininum size if they exist
if (length(dist_bounds) > 0) {
sig_bounds = sig_bounds[-dist_bounds]
}
#Create TADs using significant boundaries
TAD_start = c(1, sig_bounds+1)
TAD_end = c(sig_bounds, nrow(sub_filt))
widths = (TAD_end-TAD_start)+1
memberships = unlist(lapply(1:length(TAD_start), function(x) rep(x,widths[x])))
#Create groups
if (length(sig_bounds) == 0) {
#Create empty set if non-significant
end_group = dplyr::bind_rows()
} else {
sig_bounds = which(scale(point_dist[-length(point_dist)])>2)
#Remove boundaries within the minimum size
sig_bounds = subset(sig_bounds, sig_bounds>min_size)
#2*min_size is to offset and remove the second occurence
dist_bounds = which(c(min_size*2,diff(sig_bounds))<min_size)
#Assign IDs based on coordinate and groups based on significant boundaries
end_group = data.frame(ID = as.numeric(colnames(sub_filt)), Group = memberships)
#Compile into bed file
end_group = end_group %>% dplyr::mutate(group_place = Group) %>% dplyr::group_by(group_place) %>% dplyr::mutate(Group = last(ID)) %>% dplyr::ungroup() %>% dplyr::select(ID, Group)
}
} else {
#Find largest gaps
gap_order = order(-point_dist)
#Remove boundaries occuring before minimum size at the very beginning of window
#gap_order = gap_order[-which(gap_order<min_size)]
#Initialize silhouette score
sil_score = c()
for (cluster in clusters) {
#Loop through first k gaps and remove repeating boundaries
#Set intial cutpoints to the number of clusters
k = 1
partition_found = 0
first_run = TRUE
cutpoints = c()
#Loop through cluster numbers by iteratively adding new candidate boundaries and testing
while(partition_found == 0) {
#Get candidate gaps
new_gap = gap_order[k]
cutpoints = c(cutpoints, new_gap)
#Identify gaps which are closer together than the minimum TAD size
diff_points = which( abs(new_gap-cutpoints[-length(cutpoints)]) <= min_size)
#If a point exists that is too close to another, remove it
if (length(diff_points)>0) {
cutpoints = cutpoints[-length(cutpoints)]
}
#If not these are final clusters
if (length(cutpoints) == cluster) {
partition_found = 1
} else {
k = k+1
}
}
#If the new candidate cluster is an NA value, ignore
if (any(is.na(cutpoints))) {
next
}
#Order
cutpoints = cutpoints[order(cutpoints)]
#Combine cutpoints with start and end of window
cutpoints = c(1, cutpoints, length(non_gaps_within)+1)
#Find size of each cluster (TAD)
group_size = diff(cutpoints)
#Assign locations of the window memberships based on cutpoints
memberships = c()
for (i in 1:length(group_size)) {
memberships = c(memberships, rep(i,times = group_size[i]))
}
#Get silhouette score for current number of clusters (TADs)
sil = summary(cluster::silhouette(memberships,dist_sub))
#Save silhouette scores for each configuration in vector
sil_score = c(sil_score, sil$si.summary[4])
#Save memberships in list
Group_mem[[cluster]] = memberships
}
#Pull out the cutpoints which maximize silhouette score
end_group = Group_mem[[which(diff(sil_score)<0)[1]]]
#Put coordinates and group IDs into data frame
end_group = data.frame(ID = as.numeric(colnames(sub_filt)), Group = end_group)
#Convert IDs to coordinates of endpoint to avoid overlaps
end_group = end_group %>%dplyr::mutate(group_place = Group) %>%dplyr::group_by(group_place) %>%dplyr::mutate(Group = max(ID)) %>% ungroup() %>% dplyr::select(ID, Group)
}
#End while loop if window reaches end of contact matrix
if (end == nrow(cont_mat)) {
Group_over = dplyr::bind_rows(Group_over, end_group)
end_loop = 1
} else {
#Remove the last group (To account for overlap across windows) and set new start to start of group
end_IDs = which(end_group$Group == last(end_group$Group))
start = end-length(end_IDs)+1
#Account for cases when final TAD can't be removed
if (length(start) == 0 ) {
start = end
}
#Set new window end
end = start+window_size
#Remove final group to avoid repeating
end_group = end_group[-end_IDs, ]
#Combine TAD coordinates into single bed file
Group_over = dplyr::bind_rows(Group_over, end_group)
#Set end point to end of contact matrix if window is larger than end of matrix
if ( (end + (2000000/resolution)) > nrow(cont_mat) ) {
end = nrow(cont_mat)
}
}
}
start
end
nrow(cont_mat)
end + (2000000/resolution)) > nrow(cont_mat)
2000000/resolution
end
SpectralTAD(n_n, chr = "chr22")
SpectralTAD(rao_chr20_25_rep, chr = "chr22")
if (all(is.finite(cont_mat)) == FALSE) {
stop("Contact matrix must only contain real numbers")
}
cont_mat = n_n_3
start_coords = cont_mat[,2]
resolution = as.numeric(cont_mat[1,3])-as.numeric(cont_mat[1,2])
cont_mat = cont_mat[,-c(1:3)]
if (all(is.finite(cont_mat)) == FALSE) {
stop("Contact matrix must only contain real numbers")
}
cont_mat = n_n_3
start_coords = cont_mat[,2]
resolution = as.numeric(cont_mat[1,3])-as.numeric(cont_mat[1,2])
cont_mat = as.matrix(cont_mat[,-c(1:3)])
if (all(is.finite(cont_mat)) == FALSE) {
stop("Contact matrix must only contain real numbers")
}
colnames(cont_mat) = start_coords
SpectralTAD = function(cont_mat, chr, levels = 1, qual_filter = TRUE, z_clust = FALSE, eigenvalues = 2, min_size = 5, resolution = "auto", gap_threshold = 1) {
#Calculate the number of rows and columns of the contact matrix
if (missing("chr")) {
stop("Must specify chromosome")
}
row_test = dim(cont_mat)[1]
col_test = dim(cont_mat)[2]
if (row_test == col_test) {
if (all(is.finite(cont_mat)) == FALSE) {
stop("Contact matrix must only contain real numbers")
}
}
if (col_test == 3) {
#Convert sparse matrix to n x n matrix
message("Converting to n x n matrix")
cont_mat = HiCcompare::sparse2full(cont_mat)
if (all(is.finite(cont_mat)) == FALSE) {
stop("Contact matrix must only contain real numbers")
}
if (resolution == "auto") {
message("Estimating resolution")
resolution = as.numeric(names(table(as.numeric(colnames(cont_mat))-lag(as.numeric(colnames(cont_mat)))))[1])
}
} else if (col_test-row_test == 3) {
message("Converting to n x n matrix")
#Find the start coordinates based on the second column of the bed file portion of matrix
start_coords = cont_mat[,2]
#Calculate resolution based on given bin size in bed file
resolution = as.numeric(cont_mat[1,3])-as.numeric(cont_mat[1,2])
#Remove bed file portion
cont_mat = as.matrix(cont_mat[,-c(1:3)])
if (all(is.finite(cont_mat)) == FALSE) {
stop("Contact matrix must only contain real numbers")
}
#Make column names correspond to bin start
colnames(cont_mat) = start_coords
} else if (col_test!=3 & (row_test != col_test) & (col_test-row_test != 3)) {
#Throw error if matrix does not correspond to known matrix type
stop("Contact matrix must be sparse or n x n or n x (n+3)!")
break
} else if ( (resolution == "auto") & (col_test-row_test == 0) ) {
message("Estimating resolution")
#Estimating resolution based on most common distance between loci
resolution = as.numeric(names(table(as.numeric(colnames(cont_mat))-lag(as.numeric(colnames(cont_mat)))))[1])
}
#Performed window spectral clustering
bed = .windowedSpec(cont_mat, chr = chr, resolution = resolution, z_clust = z_clust, eigenvalues = eigenvalues, min_size = min_size, qual_filter = qual_filter, gap_threshold = gap_threshold) %>% mutate(Level = 1)
#Calculate the end point of TADs based on bin instead of genomic coordinate
coords = cbind(match(bed$start, as.numeric(colnames(cont_mat))), match(bed$end-resolution, as.numeric(colnames(cont_mat))))
#Create a list of tad start and end points
tads = apply(coords, 1, function(x) cont_mat[x[1]:x[2], x[1]:x[2]])
called_tads = list(bed)
#Initialize TAD level
curr_lev = 2
while (curr_lev != (levels + 1) ) {
#Get a list of TAD coordinates at the previous level
coords = cbind(match(called_tads[[curr_lev-1]]$start, as.numeric(colnames(cont_mat))), match(called_tads[[curr_lev-1]]$end-resolution, as.numeric(colnames(cont_mat))))
#Get tads that are less than the twice the minmium length and thus not seperable
less_5 = which( (coords[,2]-coords[,1])<min_size*2  )
if (length(less_5)>0) {
#Remove TADs which cannot be seperate
pres_tads = called_tads[[curr_lev-1]][less_5,]
coords = coords[-less_5, ]
} else {
pres_tads = c()
}
#Account for the situation where there is only 1 potential sub-tad
if (is.null(nrow(coords))) {
coords = t(as.matrix(coords))
}
tads = apply(coords, 1, function(x) cont_mat[x[1]:x[2], x[1]:x[2]])
#Remove sub-tads with too many zeros
zeros = which(unlist(lapply(tads, function(x) nrow(x)-sum(rowSums(x)==0)))<min_size*2)
if (length(zeros)>0) {
pres_tads = rbind(pres_tads, called_tads[[curr_lev-1]][zeros,])
tads[zeros] = NULL
}
#Calculate sub-TADs for each seperable TAD
sub_tads = lapply(tads, function(x) {
.windowedSpec(x, chr =chr, resolution = resolution, qual_filter = qual_filter, z_clust = TRUE, min_size = min_size)
})
#Create a bed file for sub-TADs
called_tads[[curr_lev]] = bind_rows(sub_tads, pres_tads) %>% mutate(Level = curr_lev) %>% arrange(start)
curr_lev = curr_lev+1
}
#Assign names based on levels
names(called_tads) = paste0("Level_", 1:levels)
return(called_tads)
}
SpectralTAD(n_n_3, chr = "chr22")
SpectralTAD(as.matrix(n_n_3), chr = "chr22")
SpectralTAD(n_n_3, chr = "chr22")
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
devtools::install_github("cresswellkg/SpectralTAD")
#Benchmarking different parameters
microbenchmark(SpectralTAD(cont_mat = rao_chr20_25_rep, chr = "chr20", qual_filter = FALSE), SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE), SpectralTAD(cont_mat = n_n_3, chr = "chr20", qual_filter = FALSE), unit = "s")
#Benchmarking different parameters
microbenchmark(SpectralTAD(cont_mat = rao_chr20_25_rep, chr = "chr20", qual_filter = FALSE), SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE), SpectralTAD(cont_mat = n_n_3, chr = "chr20", qual_filter = FALSE), unit = "s", times = 5)
#Defining each function
sparse = SpectralTAD(cont_mat = rao_chr20_25_rep, chr = "chr20", qual_filter = FALSE)
n_by_n = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE)
n_by_n_3 =SpectralTAD(cont_mat = n_n_3, chr = "chr20", qual_filter = FALSE)
#Benchmarking different parameters
microbenchmark(sparse, n_by_n, n_by_n_3, unit = "s", times = 3)
#Benchmarking different parameters
microbenchmark(sparse = SpectralTAD(cont_mat = rao_chr20_25_rep, chr = "chr20", qual_filter = FALSE),
n_by_n = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE),
n_by_n_3 =SpectralTAD(cont_mat = n_n_3, chr = "chr20", qual_filter = FALSE), unit = "s", times = 3)
microbenchmark(quality_filter = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = TRUE, z_clust = FALSE), no_filter = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE, z_clust = FALSE), z_clust = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE, z_clust = TRUE))
microbenchmark(quality_filter = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = TRUE, z_clust = FALSE), no_filter = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE, z_clust = FALSE), z_clust = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE, z_clust = TRUE), times = 3, units = "s")
microbenchmark(quality_filter = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = TRUE, z_clust = FALSE), no_filter = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE, z_clust = FALSE), z_clust = SpectralTAD(cont_mat = n_n, chr = "chr20", qual_filter = FALSE, z_clust = TRUE), times = 3, unit = "s")
library(SpectralTAD)
#Find TADs
tads = SpectralTAD(rao_chr20_25_rep, chr = "chr20")
tads$Level_1
#Find TADs
tads = SpectralTAD(rao_chr20_25_rep, chr = "chr20", levels = 2, qual_filter = FALSE)
tads$Level_1
tads$Level_2
row.names(rao_chr20_25_rep) = NULL
rao_chr20_25_rep
sub_mat = cbind.data.frame("chr19", as.numeric(colnames(rao_chr20_25_rep)), as.numeric(colnames(rao_chr20_25_rep))+25000, rao_chr20_25_rep)[1:10, 1:10]
rao_chr20_25_rep = sparse2full(rao_chr20_25_rep)
rao_chr20_25_rep = HiCcompare::sparse2full(rao_chr20_25_rep)
row.names(rao_chr20_25_rep) = NULL
sub_mat = cbind.data.frame("chr19", as.numeric(colnames(rao_chr20_25_rep)), as.numeric(colnames(rao_chr20_25_rep))+25000, rao_chr20_25_rep)[1:10, 1:10]
colnames(sub_mat) = NULL
sub_mat
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
#devtools::install_github("cresswellkg/SpectralTAD")
library(SpectralTAD)
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
#devtools::install_github("cresswellkg/SpectralTAD")
library(SpectralTAD)
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
devtools::install_github("cresswellkg/SpectralTAD")
install()
require(devtools)
install()
devtools::install()
usethis::install()
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
devtools::install_github("cresswellkg/SpectralTAD")
library(SpectralTAD)
library(dplyr)
require(SpectralTAD)
.libPaths()
ls(.libPaths())
.libPaths()
installed.packages
installed.packages()
debug(installed.packages)
source("http://bioconductor.org/biocLite.R")
biocLite("BiocStyle")
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
devtools::install_github("cresswellkg/SpectralTAD")
library(SpectralTAD)
SpectralTAD_Par = function(cont_list, chr_over, labels = NULL, levels = 1,  qual_filter = FALSE, z_clust = FALSE, eigenvalues = 2, min_size =5, cores = "auto", resolution = "auto") {
if (cores == "auto") {
# Check how many cores you have
numCores <- parallel::detectCores()
} else {
numCores = cores
}
# Set the number of cores at least one less than the total number
if(Sys.info()['sysname'] == "Windows") {
# Windows settings
BiocParallel::register(BiocParallel::SnowParam(workers = numCores - 1), default = TRUE)
} else {
# Unix settings
BiocParallel::register(BiocParallel::MulticoreParam(workers = numCores - 1), default = TRUE)
}
#Run SpectralTAD simultaneously on each contact matrix
bed = BiocParallel::bplapply(1:length(cont_list), function(x, spec_fun, cont_list,eigenvalues, z_clust, qual_filter, levels, min_size, chr_over, gap_threshold) spec_fun(cont_mat = cont_list[[x]],  chr_over[[x]], levels = levels, qual_filter = qual_filter, z_clust = z_clust, eigenvalues = eigenvalues, min_size = min_size), spec_fun = SpectralTAD, cont_list = cont_list, eigenvalues = eigenvalues, min_size = min_size, levels = levels,z_clust = z_clust, qual_filter = qual_filter, chr_over = chr_over, gap_threshold = gap_threshold)
#Assign labels to identify each contact matrix
if (!is.null(labels)) {
if (length(labels) != length(cont_list)) {
warning("Labels ignored: Labels not same length as list of contact matrices")
labels = NULL
}
names(bed) = labels
}
return(bed)
}
cont_mat = data("rao_chr20_25_rep")
cont_mat = sparse2full(cont_mat)
data("rao_chr25_rep")
data("rao_chr20_25_rep")
remove(cont_mat)
rao_chr20_25_rep
cont_mat = rao_chr20_25_rep
SpectralTAD_Par = function(cont_list, chr_over, labels = NULL, levels = 1,  qual_filter = FALSE, z_clust = FALSE, eigenvalues = 2, min_size =5, cores = "auto", resolution = "auto") {
if (cores == "auto") {
# Check how many cores you have
numCores <- parallel::detectCores()
} else {
numCores = cores
}
# Set the number of cores at least one less than the total number
if(Sys.info()['sysname'] == "Windows") {
# Windows settings
BiocParallel::register(BiocParallel::SnowParam(workers = numCores - 1), default = TRUE)
} else {
# Unix settings
BiocParallel::register(BiocParallel::MulticoreParam(workers = numCores - 1), default = TRUE)
}
#Run SpectralTAD simultaneously on each contact matrix
bed = BiocParallel::bplapply(1:length(cont_list), function(x, spec_fun, cont_list,eigenvalues, z_clust, qual_filter, levels, min_size, chr_over, gap_threshold) spec_fun(cont_mat = cont_list[[x]],  chr_over[[x]], levels = levels, qual_filter = qual_filter, z_clust = z_clust, eigenvalues = eigenvalues, min_size = min_size), spec_fun = SpectralTAD, cont_list = cont_list, eigenvalues = eigenvalues, min_size = min_size, levels = levels,z_clust = z_clust, qual_filter = qual_filter, chr_over = chr_over, gap_threshold = gap_threshold)
#Assign labels to identify each contact matrix
if (!is.null(labels)) {
if (length(labels) != length(cont_list)) {
warning("Labels ignored: Labels not same length as list of contact matrices")
labels = NULL
}
names(bed) = labels
}
return(bed)
}
SpectralTAD_Par(cont_mat)
SpectralTAD_Par(cont_mat, chr_over = "chr20")
SpectralTAD_Par = function(cont_list, chr_over, labels = NULL, levels = 1,  qual_filter = FALSE, z_clust = FALSE, eigenvalues = 2, min_size =5, cores = "auto", resolution = "auto", gap_threshold = 1) {
if (cores == "auto") {
# Check how many cores you have
numCores <- parallel::detectCores()
} else {
numCores = cores
}
# Set the number of cores at least one less than the total number
if(Sys.info()['sysname'] == "Windows") {
# Windows settings
BiocParallel::register(BiocParallel::SnowParam(workers = numCores - 1), default = TRUE)
} else {
# Unix settings
BiocParallel::register(BiocParallel::MulticoreParam(workers = numCores - 1), default = TRUE)
}
#Run SpectralTAD simultaneously on each contact matrix
bed = BiocParallel::bplapply(1:length(cont_list), function(x, spec_fun, cont_list,eigenvalues, z_clust, qual_filter, levels, min_size, chr_over, gap_threshold) spec_fun(cont_mat = cont_list[[x]],  chr_over[[x]], levels = levels, qual_filter = qual_filter, z_clust = z_clust, eigenvalues = eigenvalues, min_size = min_size), spec_fun = SpectralTAD, cont_list = cont_list, eigenvalues = eigenvalues, min_size = min_size, levels = levels,z_clust = z_clust, qual_filter = qual_filter, chr_over = chr_over, gap_threshold = gap_threshold)
#Assign labels to identify each contact matrix
if (!is.null(labels)) {
if (length(labels) != length(cont_list)) {
warning("Labels ignored: Labels not same length as list of contact matrices")
labels = NULL
}
names(bed) = labels
}
return(bed)
}
SpectralTAD_Par(cont_mat, chr_over = "chr20")
SpectralTAD_Par(list(cont_mat), chr_over = "chr20")
SpectralTAD_Par(list(cont_mat, cont_mat), chr_over = list("chr20", "chr20"))
SpectralTAD_Par(list(cont_mat, cont_mat), chr_over = list("chr20", "chr19"), labels = c("primary 1", "primary 2"))
vignette("SpectralTAD")
vignette()
devtools::install(build_vignettes = TRUE)
vignette("SpectralTAD")
rao_chr20_25_rep[1:5, 1:5]
# Chunk 1: set-options
options(width = 400)
# Chunk 2
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
#devtools::install_github("cresswellkg/SpectralTAD")
library(SpectralTAD)
# Chunk 3
data("rao_chr20_25_rep")
rao_chr20_25_rep = HiCcompare::sparse2full(rao_chr20_25_rep)
rao_chr20_25_rep[1:5, 1:5]
row.names(rao_chr20_25_rep) = as.numeric(row.names(rao_chr20_25_rep))
rao_chr20_25_rep[1:5, 1:5]
options(scipen = 10)
rao_chr20_25_rep[1:5, 1:5]
options(scipen = 999)
rao_chr20_25_rep[1:5, 1:5]
format(row.names(rao_chr20_25_rep))
format(row.names(rao_chr20_25_rep), scientific = FALSE)
format(as.numeric(row.names(rao_chr20_25_rep)), scientific = FALSE)
row.names = format(as.numeric(row.names(rao_chr20_25_rep)), scientific = FALSE)
row.names(rao_chr20_25_rep) = format(as.numeric(row.names(rao_chr20_25_rep)), scientific = FALSE)
rao_chr20_25_rep[1:5, 1:5]
row.names(rao_chr20_25_rep) = col.names(rao_chr20_25_rep) = format(as.numeric(row.names(rao_chr20_25_rep)), scientific = FALSE)
row.names(rao_chr20_25_rep) = col.names(rao_chr20_25_rep) = format(as.numeric(row.names(rao_chr20_25_rep)), scientific = FALSE)
data("rao_chr20_25_rep")
rao_chr20_25_rep = HiCcompare::sparse2full(rao_chr20_25_rep)
row.names(rao_chr20_25_rep) = colnames(rao_chr20_25_rep) = format(as.numeric(row.names(rao_chr20_25_rep)), scientific = FALSE)
rao_chr20_25_rep[1:5, 1:5]
browseVignettes("SpectralTAD")
browseVignettes("SpectralTAD")
install()
install()
devtools::install()
require(SpectralTAD)
browseVignettes("SpectralTAD")
document()
devtools::document()
browseVignettes("SpectralTAD")
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
devtools::install_github("cresswellkg/SpectralTAD")
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
#devtools::install_github("cresswellkg/SpectralTAD")
library(SpectralTAD)
browseVignettes(SpectralTAD)
browseVignettes()
vignette("spectraltad.rmd")
vignette("SpectralTAD")
vignette(")
vignette()
devtools::build_vignette("SpectralTAD")
build_vignette("SpectralTAD")
build_vignettes("SpectralTAD")
devtools::build_vignettes("SpectralTAD")
devtools::build_vignettes("./vignette/SpectralTAD")
devtools::build_vignettes("./vignettes/SpectralTAD")
devtools::build_vignettes("./vignettes/SpectralTAD")
vignette("SpectralTAD")
vignette("spectraltad")
devtools::buil()
devtools::build_vignettes()
browseVignettes("SpectralTAD")
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
devtools::install_github("cresswellkg/SpectralTAD")
library(SpectralTAD)
browseVignettes()
browseVignettes
browseVignettes()
data("rao_chr20_25_rep")
rao_chr20_25_rep = HiCcompare::sparse2full(rao_chr20_25_rep)
row.names(rao_chr20_25_rep) = colnames(rao_chr20_25_rep) = format(as.numeric(row.names(rao_chr20_25_rep)), scientific = FALSE)
rao_chr20_25_rep[1:5, 1:5]
devtools::build()
browseVignettes()
install()
devtools::install()
install()
devtools::install()
build()
devtools::build()
build()
devtools::build()
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SpectralTAD")
devtools::install_github("cresswellkg/SpectralTAD")
document()
devtools::document()
devtools::document()
install()
devtools::install()
vignette(HiCcompare)
