test1 = read.table(Raw_dir[[22]])
test1 = HiCcompare::sparse2full(test1)
head(colnames(test1))
remove(test1)
hierarchicalSpec = function(cont_mat, chr, levels = 1, qual_filter = TRUE, z_clust = FALSE, eigenvalues = 2, min_size =5, resolution = "auto") {
source("windowedSpec.R")
row_test = dim(cont_mat)[1]
col_test = dim(cont_mat)[2]
if (col_test == 3) {
cont_mat = HiCcompare::sparse2full(cont_mat)
message("Converting to n x n matrix")
} else if (col_test-row_test == 3) {
message("Converting to n x n matrix")
start_coords = cont_mat[,2]
cont_mat = cont_mat[,-c(1:3)]
colnames(cont_mat) = start_coords
} else if (col_test!=3 & row_test != col_test) {
stop("Contact matrix must be sparse or square!")
break
}
if (resolution == "auto") {
resolution = as.numeric(colnames(cont_mat)[2])-as.numeric(colnames(cont_mat)[1])
} else {
resolution = resolution
}
bed = windowedSpec(cont_mat, chr = chr, resolution = resolution, z_clust = z_clust, eigenvalues = eigenvalues, min_size = min_size, qual_filter = qual_filter) %>% mutate(Level = 1)
coords = cbind(match(bed$start, as.numeric(colnames(cont_mat))), match(bed$end-resolution, as.numeric(colnames(cont_mat))))
tads = apply(coords, 1, function(x) cont_mat[x[1]:x[2], x[1]:x[2]])
called_tads = list(bed)
curr_lev = 2
while (curr_lev != (levels +1) ) {
coords = cbind(match(called_tads[[curr_lev-1]]$start, as.numeric(colnames(cont_mat))), match(called_tads[[curr_lev-1]]$end-resolution, as.numeric(colnames(cont_mat))))
#Get rows that are less than 10 in length and thus not seperable
less_5 = which( (coords[,2]-coords[,1])<10  )
if (length(less_5)>0) {
#Pull them out
pres_tads = called_tads[[curr_lev-1]][less_5,]
coords = coords[-less_5, ]
} else {
pres_tads = c()
}
tads = apply(coords, 1, function(x) cont_mat[x[1]:x[2], x[1]:x[2]])
#Remove sub-tads with too many zeros
zeros = which(unlist(lapply(tads, function(x) nrow(x)-sum(rowSums(x)==0)))<10)
if (length(zeros)>0) {
pres_tads = rbind(pres_tads, called_tads[[curr_lev-1]][zeros,])
tads[zeros] = NULL
}
sub_tads = lapply(tads, function(x) {
windowedSpec(x, chr =chr, resolution = resolution, qual_filter = qual_filter, z_clust = FALSE, min_size = min_size)
})
called_tads[[curr_lev]] = bind_rows(sub_tads, pres_tads) %>% mutate(Level = curr_lev) %>% arrange(start)
curr_lev = curr_lev+1
}
names(called_tads) = paste0("Level_", 1:levels)
return(called_tads)
}
remove(test1)
col_3 = HiCcompare::sparse2full(sparse_mat)
three_col = cbind.data.frame("chr22", as.numeric(colnames(col_3)), as.numeric(colnames(col_3))+25000, col_3)
hierarchicalSpec = function(cont_mat, chr, levels = 1, qual_filter = TRUE, z_clust = FALSE, eigenvalues = 2, min_size =5, resolution = "auto") {
source("windowedSpec.R")
row_test = dim(cont_mat)[1]
col_test = dim(cont_mat)[2]
if (col_test == 3) {
cont_mat = HiCcompare::sparse2full(cont_mat)
message("Converting to n x n matrix")
} else if (col_test-row_test == 3) {
message("Converting to n x n matrix")
start_coords = cont_mat[,2]
cont_mat = cont_mat[,-c(1:3)]
colnames(cont_mat) = start_coords
} else if (col_test!=3 & row_test != col_test) {
stop("Contact matrix must be sparse or square!")
break
}
if (resolution == "auto") {
resolution = as.numeric(colnames(cont_mat)[2])-as.numeric(colnames(cont_mat)[1])
} else {
resolution = resolution
}
bed = windowedSpec(cont_mat, chr = chr, resolution = resolution, z_clust = z_clust, eigenvalues = eigenvalues, min_size = min_size, qual_filter = qual_filter) %>% mutate(Level = 1)
coords = cbind(match(bed$start, as.numeric(colnames(cont_mat))), match(bed$end-resolution, as.numeric(colnames(cont_mat))))
tads = apply(coords, 1, function(x) cont_mat[x[1]:x[2], x[1]:x[2]])
called_tads = list(bed)
curr_lev = 2
while (curr_lev != (levels +1) ) {
coords = cbind(match(called_tads[[curr_lev-1]]$start, as.numeric(colnames(cont_mat))), match(called_tads[[curr_lev-1]]$end-resolution, as.numeric(colnames(cont_mat))))
#Get rows that are less than 10 in length and thus not seperable
less_5 = which( (coords[,2]-coords[,1])<10  )
if (length(less_5)>0) {
#Pull them out
pres_tads = called_tads[[curr_lev-1]][less_5,]
coords = coords[-less_5, ]
} else {
pres_tads = c()
}
tads = apply(coords, 1, function(x) cont_mat[x[1]:x[2], x[1]:x[2]])
#Remove sub-tads with too many zeros
zeros = which(unlist(lapply(tads, function(x) nrow(x)-sum(rowSums(x)==0)))<10)
if (length(zeros)>0) {
pres_tads = rbind(pres_tads, called_tads[[curr_lev-1]][zeros,])
tads[zeros] = NULL
}
sub_tads = lapply(tads, function(x) {
windowedSpec(x, chr =chr, resolution = resolution, qual_filter = qual_filter, z_clust = FALSE, min_size = min_size)
})
called_tads[[curr_lev]] = bind_rows(sub_tads, pres_tads) %>% mutate(Level = curr_lev) %>% arrange(start)
curr_lev = curr_lev+1
}
names(called_tads) = paste0("Level_", 1:levels)
return(called_tads)
}
hierarchicalSpec(three_col)
setwd("./R")
hierarchicalSpec(three_col)
hierarchicalSpec(chr = "chr22", three_col)
hierarchicalSpec = function(cont_mat, chr, levels = 1, qual_filter = TRUE, z_clust = FALSE, eigenvalues = 2, min_size =5, resolution = "auto") {
source("windowedSpec.R")
#Calculate the number of rows and columns of the contact matrix
row_test = dim(cont_mat)[1]
col_test = dim(cont_mat)[2]
if (col_test == 3) {
#Convert sparse matrix to n x n matrix
cont_mat = HiCcompare::sparse2full(cont_mat)
message("Converting to n x n matrix")
} else if (col_test-row_test == 3) {
message("Converting to n x n matrix")
#Find the start coordinates based on the second column of the bed file portion of matrix
start_coords = cont_mat[,2]
#Calculate resolution based on given bin size in bed file
resolution = as.numeric(cont_mat[1,3])-as.numeric(cont_mat[1,2])
#Remove bed file portion
cont_mat = cont_mat[,-c(1:3)]
#Make column names correspond to bin start
colnames(cont_mat) = start_coords
} else if (col_test!=3 & row_test != col_test & col_test-row_test != 3) {
#Throw error if matrix does not correspond to known matrix type
stop("Contact matrix must be sparse or n x n or n x (n+3)!")
break
}
#Automatically estimate resolution based on distance between first two bin start points
if (resolution == "auto") {
resolution = as.numeric(colnames(cont_mat)[2])-as.numeric(colnames(cont_mat)[1])
} else {
resolution = resolution
}
bed = windowedSpec(cont_mat, chr = chr, resolution = resolution, z_clust = z_clust, eigenvalues = eigenvalues, min_size = min_size, qual_filter = qual_filter) %>% mutate(Level = 1)
coords = cbind(match(bed$start, as.numeric(colnames(cont_mat))), match(bed$end-resolution, as.numeric(colnames(cont_mat))))
tads = apply(coords, 1, function(x) cont_mat[x[1]:x[2], x[1]:x[2]])
called_tads = list(bed)
curr_lev = 2
while (curr_lev != (levels +1) ) {
coords = cbind(match(called_tads[[curr_lev-1]]$start, as.numeric(colnames(cont_mat))), match(called_tads[[curr_lev-1]]$end-resolution, as.numeric(colnames(cont_mat))))
#Get rows that are less than 10 in length and thus not seperable
less_5 = which( (coords[,2]-coords[,1])<10  )
if (length(less_5)>0) {
#Pull them out
pres_tads = called_tads[[curr_lev-1]][less_5,]
coords = coords[-less_5, ]
} else {
pres_tads = c()
}
tads = apply(coords, 1, function(x) cont_mat[x[1]:x[2], x[1]:x[2]])
#Remove sub-tads with too many zeros
zeros = which(unlist(lapply(tads, function(x) nrow(x)-sum(rowSums(x)==0)))<10)
if (length(zeros)>0) {
pres_tads = rbind(pres_tads, called_tads[[curr_lev-1]][zeros,])
tads[zeros] = NULL
}
sub_tads = lapply(tads, function(x) {
windowedSpec(x, chr =chr, resolution = resolution, qual_filter = qual_filter, z_clust = FALSE, min_size = min_size)
})
called_tads[[curr_lev]] = bind_rows(sub_tads, pres_tads) %>% mutate(Level = curr_lev) %>% arrange(start)
curr_lev = curr_lev+1
}
names(called_tads) = paste0("Level_", 1:levels)
return(called_tads)
}
hierarchicalSpec(chr = "chr22", three_col)
tads
max_size
crossprod
Matrix::crossprod()
kronecker
require(usethis)
use_package("dplyr, type = "Imports"")
use_package("dplyr, type = "Imports")
use_package("dplyr", type = "Imports")
use_package("PRIMME", type = "Imports")
use_package("cluster", type = "Imports")
use_package("Matrix", type = "Imports")
document()
require(devtools)
document()
setwd("../..")
install("SpectralTAD")
hierarchicalSpec
.windowedSpec = function(cont_mat, resolution, chr,
gap_filter = TRUE,z_clust = FALSE,  qual_filter = TRUE, eigenvalues = 2, min_size = 5) {
#Set window sized based on biologically maximum TAD size of 2000000
window_size = ceiling(2000000/resolution)
#Find all regions which aren't completely zero and remove those that are
non_gaps = which(colSums(cont_mat) !=0)
cont_mat = cont_mat[non_gaps,non_gaps]
#Get end point of the first window
Group_over = dplyr::bind_rows()
#Initialize first window
start = 1
end = window_size
#Set parameter for determining end of loop
end_loop = 0
#Test if start+window is larger than the contact matrix and correct end point
if (end+window_size>nrow(cont_mat)) {
end = nrow(cont_mat)
}
#Begin sliding window clustering
while (end_loop == 0) {
#Subset matrix based on window size
sub_filt = cont_mat[start:end, start:end]
#Calculate distance matrix for silhouette score
dist_sub = 1/(1+sub_filt)
#Get degree matrix
dr = rowSums(abs(sub_filt))
#Creating the normalized laplacian
Dinvsqrt = diag((1/sqrt(dr+2e-16)))
P_Part1 = Matrix::crossprod(as.matrix(sub_filt), Dinvsqrt)
sub_mat = Matrix::crossprod(Dinvsqrt, P_Part1)
colnames(sub_mat) = colnames(cont_mat)[start:end]
#Get first k eigenvectors
Eigen = PRIMME::eigs_sym(sub_mat, NEig = eigenvalues)
eig_vals = Eigen$values
eig_vecs = Eigen$vectors
#Get order of eigenvalues from largest to smallest
large_small = order(-eig_vals)
eig_vals = eig_vals[large_small]
eig_vecs = eig_vecs[,large_small]
index = 1
Group_mem = list()
#Calculate the range of possible clusters
clusters = 1:ceiling( (end-start+1)/min_size)
#Normalize the eigenvectors from 0-1
norm_ones = sqrt(dim(sub_mat)[2])
for (i in 1:dim(eig_vecs)[2]) {
eig_vecs[,i] = (eig_vecs[,i]/sqrt(sum(eig_vecs[,i]^2)))  * norm_ones
if (eig_vecs[1,i] !=0) {
eig_vecs[,i] = -1*eig_vecs[,i] * sign(eig_vecs[1,i])
}
}
n = dim(eig_vecs)[1]
k = dim(eig_vecs)[2]
#Project eigenvectors onto a unit circle
vm = matrix(kronecker(rep(1,k), as.matrix(sqrt(rowSums(eig_vecs^2)))),n,k)
eig_vecs = eig_vecs/vm
#Get distance between points on circle
point_dist = sqrt(rowSums( (eig_vecs-rbind(NA,eig_vecs[-nrow(eig_vecs),]))^2  ))
#Use z-score to select significant gaps
if (z_clust) {
#Get statisticaly significant boundaries
sig_bounds = which(scale(point_dist[-length(point_dist)])>2)
#Remove boundaries within the minimum size
sig_bounds = subset(sig_bounds, sig_bounds>min_Size)
#2*min_size is to offset and remove the second occurence
dist_bounds = which(c(min_size*2,diff(sig_bounds))<min_size)
#Remove bounds within the mininum size if they exist
if (length(dist_bounds) > 0) {
sig_bounds = sig_bounds[-dist_bounds]
}
#Create TADs using significant boundaries
TAD_start = c(1, sig_bounds+1)
TAD_end = c(sig_bounds, nrow(sub_filt))
widths = (TAD_end-TAD_start)+1
memberships = unlist(lapply(1:length(TAD_start), function(x) rep(x,widths[x])))
#Create groups
if (length(sig_bounds) == 0) {
#Create empty set if non-significant
end_group = dplyr::bind_rows()
} else {
#Assign IDs based on coordinate and groups based on significant boundaries
end_group = data.frame(ID = as.numeric(colnames(sub_filt)), Group = memberships)
#Compile into bed file
end_group = end_group %>% dplyr::mutate(group_place = Group) %>% dplyr::group_by(group_place) %>% dplyr::mutate(Group = last(ID)) %>% dplyr::ungroup() %>% dplyr::select(ID, Group)
}
} else {
#Find largest gaps
gap_order = order(-point_dist)
#Remove boundaries occuring before minimum size at the very beginning of window
gap_order = gap_order[-which(gap_order<min_size)]
#Initialize silhouette score
sil_score = c()
for (cluster in clusters) {
#Loop through first k gaps and remove repeating boundaries
#Set intial cutpoints to the number of clusters
k = 1
partition_found = 0
first_run = TRUE
cutpoints = c()
#Loop through cluster numbers by iteratively adding new candidate boundaries and testing
while(partition_found == 0) {
#Get candidate gaps
new_gap = gap_order[k]
cutpoints = c(cutpoints, new_gap)
#Identify gaps which are closer together than the minimum TAD size
diff_points = which( abs(new_gap-cutpoints[-length(cutpoints)]) <= min_size)
#If a point exists that is too close to another, remove it
if (length(diff_points)>0) {
cutpoints = cutpoints[-length(cutpoints)]
}
#If not these are final clusters
if (length(cutpoints) == cluster) {
partition_found = 1
} else {
k = k+1
}
}
#If the new candidate cluster is an NA value, ignore
if (any(is.na(cutpoints))) {
next
}
#Order
cutpoints = cutpoints[order(cutpoints)]
#Combine cutpoints with start and end of window
cutpoints = c(1, cutpoints, (end-start)+2)
#Find size of each cluster (TAD)
group_size = diff(cutpoints)
#Assign locations of the window memberships based on cutpoints
memberships = c()
for (i in 1:length(group_size)) {
memberships = c(memberships, rep(i,times = group_size[i]))
}
#Get silhouette score for current number of clusters (TADs)
sil = summary(cluster::silhouette(memberships,dist_sub))
#Save silhouette scores for each configuration in vector
sil_score = c(sil_score, sil$si.summary[4])
#Save memberships in list
Group_mem[[cluster]] = memberships
}
#Pull out the cutpoints which maximize silhouette score
end_group = Group_mem[[which.max(sil_score)]]
#Put coordinates and group IDs into data frame
end_group = data.frame(ID = as.numeric(colnames(sub_filt)), Group = end_group)
#Convert IDs to coordinates of endpoint to avoid overlaps
end_group = end_group %>%dplyr::mutate(group_place = Group) %>%dplyr::group_by(group_place) %>%dplyr::mutate(Group = max(ID)) %>% ungroup() %>% dplyr::select(ID, Group)
}
#End while loop if window reaches end of contact matrix
if (end == nrow(cont_mat)) {
Group_over = dplyr::bind_rows(Group_over, end_group)
end_loop = 1
} else {
#Remove the last group (To account for overlap across windows) and set new start to start of group
end_IDs = which(end_group$Group == last(end_group$Group))
start = end-length(end_IDs)+1
#Account for cases when final TAD can't be removed
if (length(start) == 0 ) {
start = end
}
#Set new window end
end = start+window_size
#Remove final group to avoid repeating
end_group = end_group[-end_IDs, ]
#Combine TAD coordinates into single bed file
Group_over = dplyr::bind_rows(Group_over, end_group)
#Set end point to end of contact matrix if window is larger than end of matrix
if ( (end + (2000000/resolution)) > nrow(cont_mat) ) {
end = nrow(cont_mat)
}
}
}
#Organize final results based on options selected
if (z_clust) {
if (nrow(Group_over) > 0) {
bed = Group_over %>% dplyr::group_by(Group) %>% dplyr::summarise(start = min(ID), end = max(ID) + resolution) %>%dplyr::mutate(chr = chr) %>% dplyr::select(chr, start, end) %>%
dplyr::filter((end-start)/resolution >= min_size) %>%dplyr::arrange(start)
} else {
bed = Group_over
}
} else {
if (qual_filter) {
#Calculate an overall distance matrix for calculating silhouette score for filtering
over_dist_mat = 1/(1+cont_mat)
sil = cluster::silhouette(Group_over$Group, over_dist_mat)
ave_sil = summary(sil)$clus.avg.widths
#Subset results based on silhouette score depending on qual_filter option
bed = Group_over %>% dplyr::group_by(Group) %>% dplyr::summarise(start = min(ID), end = max(ID) + resolution) %>% dplyr::mutate(chr = chr) %>% dplyr::select(chr, start, end) %>%
dplyr::mutate(Sil_Score = ave_sil) %>%dplyr::filter( ((end-start)/resolution >= min_size) & Sil_Score > .15)  %>%dplyr::arrange(start)
} else {
bed = Group_over %>% dplyr::group_by(Group) %>% dplyr::summarise(start = min(ID), end = max(ID) + resolution) %>% dplyr::mutate(chr = chr) %>% dplyr::select(chr, start, end) %>%dplyr::filter((end-start)/resolution >= min_size) %>% dplyr::arrange(start)
}
}
return(bed)
}
detach("SpectralTAD")
install_github("SpectralTAD", "cresswellkg")
install_github("SpectralTAD", "cresswellkg")
?install_github
install_github("SpectralTAD", "github.com/cresswellkg")
install_github("SpectralTAD", "www.github.com/cresswellkg")
install_github("cresswellkg/SpectralTAD")
require(SpectralTAD)
hierarchicalSpec
SpectralTAD::hierarchicalSpec()
SpectralTAD::hierarchicalSpec
SpectralTAD::hierarchicalSpec(sparse_mat, chr = "chr22")
setwd("./SpectralTAD")
document()
?hierarchicalSpec
?HiCcompare::hic_loess
use_package("parallel")
usethis::use_package("biocParallel")
usethis::use_package("BiocParallel")
document()
install
install()
sub_dir = Raw_dir[[6]]
sub_dir = Raw_dir[[1:6]]
sub_dir = Raw_dir[1:6]
SpectralTAD::SpectralTAD_Par(sub_dir)
install()
SpectralTAD::SpectralTAD_Par(sub_dir)
install()
chr_over = paste0("chr", 1:6)
labels = chr_over
sub_dir = lapply(Raw_dir[1:6], readr::read_table2)
sub_dir = lapply(Raw_dir[1:6], function(x) readr::read_table2(x, col_names = FALSE))
sub_dir = lapply(sub_dir, sparse2full)
chr_over = paste0("chr", 1:6)
labels = chr_over
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over =chr_over, labels =labels)
install()
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over =chr_over, labels =labels)
clusterExport
BiocParallel::clusterExport(dplyr)
parallel::clusterExport(dplyr)
parallel::clusterEvalQ(SpectralTAD, library(dplyr))
SpectralTAD
SpectralTAD_Par = function(cont_list, chr_over, labels = NA, levels = 1,  qual_filter = FALSE, z_clust = FALSE, eigenvalues = 2, min_size =5, cores = "auto", resolution = "auto") {
if (cores == "auto") {
# Check how many cores you have
numCores <- parallel::detectCores()
} else {
numCores = cores
}
# Set the number of cores at least one less than the total number
if(Sys.info()['sysname'] == "Windows") {
# Windows settings
BiocParallel::register(BiocParallel::SnowParam(workers = numCores - 1), default = TRUE)
} else {
# Unix settings
BiocParallel::register(BiocParallel::MulticoreParam(workers = numCores - 1), default = TRUE)
}
parallel::clusterEvalQ(SpectralTAD, library(dplyr))
#Run SpectralTAD simultaneously on each contact matrix
bed = BiocParallel::bplapply(1:length(cont_list), function(x, spec_fun, cont_list,eigenvalues, z_clust, qual_filter, levels, min_size, chr_over) spec_fun(cont_mat = cont_list[[x]],  chr_over[[x]], levels = levels, qual_filter = qual_filter, z_clust = z_clust, eigenvalues = eigenvalues, min_size = min_size), spec_fun = SpectralTAD, cont_list = cont_list, eigenvalues = eigenvalues, min_size = min_size, levels = levels,z_clust = z_clust, qual_filter = qual_filter, chr_over = chr_over)
#Assign labels to identify each contact matrix
if (!is.na(labels)) {
if (length(labels) != length(cont_list)) {
warning("Labels ignored: Labels not same length as contact matrices")
labels = NA
}
names(bed) = labels
}
return(bed)
}
SpectralTAD
dplyr::%>%
use_package("magrittr")
usethis::use_package("magrittr")
install()
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over = chr_over, labels = labels)
require(magrittr)
instal()
install()
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over = chr_over, labels = labels)
install()
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over = chr_over, labels = labels)
dplyr::ungroup()
dplyr::ungroup()
bed = BiocParallel::bplapply(1:length(cont_list), function(x, spec_fun, cont_list,eigenvalues, z_clust, qual_filter, levels, min_size, chr_over) spec_fun(cont_mat = cont_list[[x]],  chr_over[[x]], levels = levels, qual_filter = qual_filter, z_clust = z_clust, eigenvalues = eigenvalues, min_size = min_size), spec_fun = SpectralTAD, cont_list = cont_list, eigenvalues = eigenvalues, min_size = min_size, levels = levels,z_clust = z_clust, qual_filter = qual_filter, chr_over = chr_over, , BPPARAM = MulticoreParam())
install()
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over = chr_over, labels = labels)
document()
document()
install()
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over = chr_over, labels = labels)
document()
document()
install()
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over = chr_over, labels = labels)
install()
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over = chr_over, labels = labels)
document()
install()
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over = chr_over, labels = labels)
length(cont_list)
length(sub_dir)
length(labels)
length(chr_over)
document()
!is.na(labels)
labels
is.null
!is.null(labels)
document()
install()
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over = chr_over, labels = labels)
labels = c(1:5)
SpectralTAD::SpectralTAD_Par(sub_dir, chr_over = chr_over, labels = labels)
document()
install()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocCheck", version = "3.8")
